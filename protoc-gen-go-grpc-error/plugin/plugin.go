package plugin

import (
	"fmt"

	"github.com/gogo/protobuf/proto"
	"github.com/gogo/protobuf/protoc-gen-gogo/descriptor"
	"github.com/gogo/protobuf/protoc-gen-gogo/generator"
	"github.com/zoncoen/grpc-error-annotation/gen/annotation"
)

type plugin struct {
	*generator.Generator
	generator.PluginImports
}

// NewPlugin implements generator.Plugin interface.
func NewPlugin() generator.Plugin {
	return &plugin{}
}

// Name implements generator.Plugin interface.
func (p *plugin) Name() string {
	return "grpc-error"
}

// Init implements generator.Plugin interface.
func (p *plugin) Init(g *generator.Generator) {
	p.Generator = g
}

// Generate implements generator.Plugin interface.
func (p *plugin) Generate(file *generator.FileDescriptor) {
	p.PluginImports = generator.NewPluginImports(p.Generator)

	p.AddImport(generator.GoImportPath("context"))
	p.AddImport(generator.GoImportPath("google.golang.org/grpc"))
	p.AddImport(generator.GoImportPath("google.golang.org/grpc/codes"))
	p.AddImport(generator.GoImportPath("google.golang.org/grpc/status"))

	for _, s := range file.GetService() {
		p.generateMap(file.GetPackage(), s)
		p.generateCheckErrorInterceptor(s.GetName())
		p.generateRetryInterceptor(s)
	}
}

func (p *plugin) generateMap(packageName string, svc *descriptor.ServiceDescriptorProto) {
	p.block(fmt.Sprintf(`var map%s = map[string]struct{}`, svc.GetName()), func(p *plugin) {
		for _, m := range svc.GetMethod() {
			v, err := proto.GetExtension(m.GetOptions(), annotation.E_Error)
			if err != nil {
				continue
			}
			opt, ok := v.(*annotation.Error)
			if !ok {
				continue
			}
			if opt == nil {
				continue
			}
			methodName := fmt.Sprintf("/%s.%s/%s", packageName, svc.GetName(), m.GetName())
			for _, code := range opt.GetCodes() {
				p.P(fmt.Sprintf(`"%s/%d": struct{}{},`, methodName, code))
			}
		}
	})
}

func (p *plugin) block(leading string, inner func(p *plugin)) {
	p.P(leading, `{`)
	p.In()
	inner(p)
	p.Out()
	p.P(`}`)
}

func (p *plugin) generateCheckErrorInterceptor(serviceName string) {
	p.P(fmt.Sprintf(`// New%sCheckErrorUnaryServerInterceptor returns an interceptor to check status code.`, serviceName))
	p.P(`// The interceptor calls function f if handler returns the status code which is not included in zoncoen.api.grpc.error annotation.`)
	p.block(fmt.Sprintf(`func New%sCheckErrorUnaryServerInterceptor(f func(context.Context, *grpc.UnaryServerInfo, *status.Status)) grpc.UnaryServerInterceptor`, serviceName), func(p *plugin) {
		p.block(`return func(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (interface{}, error)`, func(p *plugin) {
			p.P(`resp, err := handler(ctx, req)`)
			p.block(`if err == nil`, func(p *plugin) {
				p.P(`return resp, nil`)
			})
			p.P(`s := status.Convert(err)`)
			p.block(`if code:= s.Code(); code != codes.OK`, func(p *plugin) {
				p.P(`// ignore the status codes which may are generated by the library`)
				p.P(`// ref. https://github.com/grpc/grpc/blob/master/doc/statuscodes.md`)
				p.block(`switch code`, func(p *plugin) {
					p.P(`case codes.Canceled, codes.Unknown, codes.DeadlineExceeded, codes.PermissionDenied, codes.ResourceExhausted, codes.Unimplemented, codes.Internal, codes.Unavailable, codes.Unauthenticated:`)
					p.In()
					p.P(`return resp, err`)
					p.Out()
				})
				p.P(`key := fmt.Sprintf("%s/%d", info.FullMethod, code)`)
				p.block(fmt.Sprintf(`if _, ok := map%s[key]; !ok`, serviceName), func(p *plugin) {
					p.P(`f(ctx, info, s)`)
				})
			})
			p.P(`return resp, err`)
		})
	})
}

func (p *plugin) generateRetryInterceptor(svc *descriptor.ServiceDescriptorProto) {
	p.P(fmt.Sprintf(`// New%sRetryUnaryClientInterceptor`, svc.GetName()))
	p.block(fmt.Sprintf(`func New%sRetryUnaryClientInterceptor() grpc.UnaryClientInterceptor`, svc.GetName()), func(p *plugin) {
		p.block(`return func(ctx context.Context, method string, req, reply interface{}, cc *grpc.ClientConn, invoker grpc.UnaryInvoker, opts ...grpc.CallOption) error`, func(p *plugin) {
			p.P(`return nil`)
		})
	})
}
